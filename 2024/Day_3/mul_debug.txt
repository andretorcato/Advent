File has  6 rows

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 712
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 171
--> Product between X and Y =       121752
--> Cummulative sum of X*Y | summ =       121752
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 506
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> Final integer | Y =  85
--> Product between X and Y =        43010
--> Cummulative sum of X*Y | summ =       164762
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 613
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 601
--> Product between X and Y =       368413
--> Cummulative sum of X*Y | summ =       533175
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 977
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 581
--> Product between X and Y =       567637
--> Cummulative sum of X*Y | summ =      1100812
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 142
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> Final integer | Y =  89
--> Product between X and Y =        12638
--> Cummulative sum of X*Y | summ =      1113450
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> Final integer | X =  64
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 644
--> Product between X and Y =        41216
--> Cummulative sum of X*Y | summ =      1154666
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 652
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 872
--> Product between X and Y =       568544
--> Cummulative sum of X*Y | summ =      1723210
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 594
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 202
--> Product between X and Y =       119988
--> Cummulative sum of X*Y | summ =      1843198
--> Sequence is over, back to the start | state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 311
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 646
--> Product between X and Y =       200906
--> Cummulative sum of X*Y | summ =      2044104
--> Sequence is over, back to the start | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 867
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 971
--> Product between X and Y =       841857
--> Cummulative sum of X*Y | summ =      2885961
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 192
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 659
--> Product between X and Y =       126528
--> Cummulative sum of X*Y | summ =      3012489
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 367
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 411
--> Product between X and Y =       150837
--> Cummulative sum of X*Y | summ =      3163326
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 841
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 862
--> Product between X and Y =       724942
--> Cummulative sum of X*Y | summ =      3888268
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 922
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 272
--> Product between X and Y =       250784
--> Cummulative sum of X*Y | summ =      4139052
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 593
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 223
--> Product between X and Y =       132239
--> Cummulative sum of X*Y | summ =      4271291
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 918
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 232
--> Product between X and Y =       212976
--> Cummulative sum of X*Y | summ =      4484267
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 760
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 145
--> Product between X and Y =       110200
--> Cummulative sum of X*Y | summ =      4594467
--> Sequence is over, back to the start | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 558
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 476
--> Product between X and Y =       265608
--> Cummulative sum of X*Y | summ =      4860075
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 855
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 134
--> Product between X and Y =       114570
--> Cummulative sum of X*Y | summ =      4974645
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 691
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 389
--> Product between X and Y =       268799
--> Cummulative sum of X*Y | summ =      5243444
--> Sequence is over, back to the start | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 352
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 712
--> Product between X and Y =       250624
--> Cummulative sum of X*Y | summ =      5494068
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 138
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 405
--> Product between X and Y =        55890
--> Cummulative sum of X*Y | summ =      5549958
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 176
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 679
--> Product between X and Y =       119504
--> Cummulative sum of X*Y | summ =      5669462
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 516
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> Final integer | Y =  55
--> Product between X and Y =        28380
--> Cummulative sum of X*Y | summ =      5697842
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> Final integer | X =  97
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 636
--> Product between X and Y =        61692
--> Cummulative sum of X*Y | summ =      5759534
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  30
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 945
--> Product between X and Y =        28350
--> Cummulative sum of X*Y | summ =      5787884
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 486
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 399
--> Product between X and Y =       193914
--> Cummulative sum of X*Y | summ =      5981798
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 277
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 667
--> Product between X and Y =       184759
--> Cummulative sum of X*Y | summ =      6166557
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 412
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> Final integer | Y =  36
--> Product between X and Y =        14832
--> Cummulative sum of X*Y | summ =      6181389
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 478
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> Final integer | Y =  68
--> Product between X and Y =        32504
--> Cummulative sum of X*Y | summ =      6213893
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 293
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 979
--> Product between X and Y =       286847
--> Cummulative sum of X*Y | summ =      6500740
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 218
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 379
--> Product between X and Y =        82622
--> Cummulative sum of X*Y | summ =      6583362
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 887
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 161
--> Product between X and Y =       142807
--> Cummulative sum of X*Y | summ =      6726169
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 156
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 481
--> Product between X and Y =        75036
--> Cummulative sum of X*Y | summ =      6801205
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 308
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> Final integer | Y =  96
--> Product between X and Y =        29568
--> Cummulative sum of X*Y | summ =      6830773
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 718
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 985
--> Product between X and Y =       707230
--> Cummulative sum of X*Y | summ =      7538003
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> Final integer | X =  84
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 469
--> Product between X and Y =        39396
--> Cummulative sum of X*Y | summ =      7577399
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 257
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 600
--> Product between X and Y =       154200
--> Cummulative sum of X*Y | summ =      7731599
--> Sequence is over, back to the start | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 660
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 909
--> Product between X and Y =       599940
--> Cummulative sum of X*Y | summ =      8331539
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 510
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 180
--> Product between X and Y =        91800
--> Cummulative sum of X*Y | summ =      8423339
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 619
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 634
--> Product between X and Y =       392446
--> Cummulative sum of X*Y | summ =      8815785
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 721
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 403
--> Product between X and Y =       290563
--> Cummulative sum of X*Y | summ =      9106348
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 500
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 291
--> Product between X and Y =       145500
--> Cummulative sum of X*Y | summ =      9251848
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 330
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 804
--> Product between X and Y =       265320
--> Cummulative sum of X*Y | summ =      9517168
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  10
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 447
--> Product between X and Y =         4470
--> Cummulative sum of X*Y | summ =      9521638
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 580
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 733
--> Product between X and Y =       425140
--> Cummulative sum of X*Y | summ =      9946778
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 247
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 1
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> Final integer | Y =   9
--> Product between X and Y =         2223
--> Cummulative sum of X*Y | summ =      9949001
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 157
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 768
--> Product between X and Y =       120576
--> Cummulative sum of X*Y | summ =     10069577
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 249
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 859
--> Product between X and Y =       213891
--> Cummulative sum of X*Y | summ =     10283468
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = { | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: {
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 382
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 788
--> Product between X and Y =       301016
--> Cummulative sum of X*Y | summ =     10584484
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 350
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 980
--> Product between X and Y =       343000
--> Cummulative sum of X*Y | summ =     10927484
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 710
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 125
--> Product between X and Y =        88750
--> Cummulative sum of X*Y | summ =     11016234
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 621
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 643
--> Product between X and Y =       399303
--> Cummulative sum of X*Y | summ =     11415537
--> Sequence is over, back to the start | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 174
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 437
--> Product between X and Y =        76038
--> Cummulative sum of X*Y | summ =     11491575
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 294
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> Final integer | Y =  93
--> Product between X and Y =        27342
--> Cummulative sum of X*Y | summ =     11518917
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 605
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 381
--> Product between X and Y =       230505
--> Cummulative sum of X*Y | summ =     11749422
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 873
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 431
--> Product between X and Y =       376263
--> Cummulative sum of X*Y | summ =     12125685
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 463
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 819
--> Product between X and Y =       379197
--> Cummulative sum of X*Y | summ =     12504882
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 961
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> Final integer | Y =  13
--> Product between X and Y =        12493
--> Cummulative sum of X*Y | summ =     12517375
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 507
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 494
--> Product between X and Y =       250458
--> Cummulative sum of X*Y | summ =     12767833
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 636
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 958
--> Product between X and Y =       609288
--> Cummulative sum of X*Y | summ =     13377121
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = # | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: #
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 539
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 800
--> Product between X and Y =       431200
--> Cummulative sum of X*Y | summ =     13808321
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 520
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 202
--> Product between X and Y =       105040
--> Cummulative sum of X*Y | summ =     13913361
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 493
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 844
--> Product between X and Y =       416092
--> Cummulative sum of X*Y | summ =     14329453
--> Sequence is over, back to the start | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 937
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 957
--> Product between X and Y =       896709
--> Cummulative sum of X*Y | summ =     15226162
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 301
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 646
--> Product between X and Y =       194446
--> Cummulative sum of X*Y | summ =     15420608
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 954
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 724
--> Product between X and Y =       690696
--> Cummulative sum of X*Y | summ =     16111304
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 695
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 132
--> Product between X and Y =        91740
--> Cummulative sum of X*Y | summ =     16203044
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 976
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 455
--> Product between X and Y =       444080
--> Cummulative sum of X*Y | summ =     16647124
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 492
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 975
--> Product between X and Y =       479700
--> Cummulative sum of X*Y | summ =     17126824
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 258
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 829
--> Product between X and Y =       213882
--> Cummulative sum of X*Y | summ =     17340706
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 779
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> Final integer | Y =  58
--> Product between X and Y =        45182
--> Cummulative sum of X*Y | summ =     17385888
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 275
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 708
--> Product between X and Y =       194700
--> Cummulative sum of X*Y | summ =     17580588
--> Sequence is over, back to the start | state = 0

Character =   | io = -2
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 546
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 476
--> Product between X and Y =       259896
--> Cummulative sum of X*Y | summ =     17840484
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = < | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 490
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 931
--> Product between X and Y =       456190
--> Cummulative sum of X*Y | summ =     18296674
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 302
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> Final integer | Y =  82
--> Product between X and Y =        24764
--> Cummulative sum of X*Y | summ =     18321438
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 625
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 374
--> Product between X and Y =       233750
--> Cummulative sum of X*Y | summ =     18555188
--> Sequence is over, back to the start | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 864
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 633
--> Product between X and Y =       546912
--> Cummulative sum of X*Y | summ =     19102100
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 748
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 1
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> Final integer | Y =   5
--> Product between X and Y =         3740
--> Cummulative sum of X*Y | summ =     19105840
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 375
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 874
--> Product between X and Y =       327750
--> Cummulative sum of X*Y | summ =     19433590
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> Final integer | X =  75
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 714
--> Product between X and Y =        53550
--> Cummulative sum of X*Y | summ =     19487140
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  60
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 389
--> Product between X and Y =        23340
--> Cummulative sum of X*Y | summ =     19510480
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 958
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 451
--> Product between X and Y =       432058
--> Cummulative sum of X*Y | summ =     19942538
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 855
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 921
--> Product between X and Y =       787455
--> Cummulative sum of X*Y | summ =     20729993
--> Sequence is over, back to the start | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 558
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 622
--> Product between X and Y =       347076
--> Cummulative sum of X*Y | summ =     21077069
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 269
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 240
--> Product between X and Y =        64560
--> Cummulative sum of X*Y | summ =     21141629
--> Sequence is over, back to the start | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 735
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 376
--> Product between X and Y =       276360
--> Cummulative sum of X*Y | summ =     21417989
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 868
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 976
--> Product between X and Y =       847168
--> Cummulative sum of X*Y | summ =     22265157
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 597
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 168
--> Product between X and Y =       100296
--> Cummulative sum of X*Y | summ =     22365453
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  40
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 231
--> Product between X and Y =         9240
--> Cummulative sum of X*Y | summ =     22374693
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 512
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 132
--> Product between X and Y =        67584
--> Cummulative sum of X*Y | summ =     22442277
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 570
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 592
--> Product between X and Y =       337440
--> Cummulative sum of X*Y | summ =     22779717
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 530
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 540
--> Product between X and Y =       286200
--> Cummulative sum of X*Y | summ =     23065917
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  20
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 999
--> Product between X and Y =        19980
--> Cummulative sum of X*Y | summ =     23085897
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 801
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 920
--> Product between X and Y =       736920
--> Cummulative sum of X*Y | summ =     23822817
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 984
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 512
--> Product between X and Y =       503808
--> Cummulative sum of X*Y | summ =     24326625
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 698
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 898
--> Product between X and Y =       626804
--> Cummulative sum of X*Y | summ =     24953429
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 890
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 685
--> Product between X and Y =       609650
--> Cummulative sum of X*Y | summ =     25563079
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 239
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 920
--> Product between X and Y =       219880
--> Cummulative sum of X*Y | summ =     25782959
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> Final integer | X =  88
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 839
--> Product between X and Y =        73832
--> Cummulative sum of X*Y | summ =     25856791
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 572
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 398
--> Product between X and Y =       227656
--> Cummulative sum of X*Y | summ =     26084447
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 752
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 549
--> Product between X and Y =       412848
--> Cummulative sum of X*Y | summ =     26497295
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  10
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 251
--> Product between X and Y =         2510
--> Cummulative sum of X*Y | summ =     26499805
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 569
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 478
--> Product between X and Y =       271982
--> Cummulative sum of X*Y | summ =     26771787
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 411
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 622
--> Product between X and Y =       255642
--> Cummulative sum of X*Y | summ =     27027429
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 784
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 824
--> Product between X and Y =       646016
--> Cummulative sum of X*Y | summ =     27673445
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 641
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 531
--> Product between X and Y =       340371
--> Cummulative sum of X*Y | summ =     28013816
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 315
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 701
--> Product between X and Y =       220815
--> Cummulative sum of X*Y | summ =     28234631
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = - | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 824
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 525
--> Product between X and Y =       432600
--> Cummulative sum of X*Y | summ =     28667231
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 732
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 854
--> Product between X and Y =       625128
--> Cummulative sum of X*Y | summ =     29292359
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> Final integer | X =  86
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 481
--> Product between X and Y =        41366
--> Cummulative sum of X*Y | summ =     29333725
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 954
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 533
--> Product between X and Y =       508482
--> Cummulative sum of X*Y | summ =     29842207
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = $ | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: $
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 482
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 558
--> Product between X and Y =       268956
--> Cummulative sum of X*Y | summ =     30111163
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> Final integer | X =  45
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 414
--> Product between X and Y =        18630
--> Cummulative sum of X*Y | summ =     30129793
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 300
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 115
--> Product between X and Y =        34500
--> Cummulative sum of X*Y | summ =     30164293
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 374
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 474
--> Product between X and Y =       177276
--> Cummulative sum of X*Y | summ =     30341569
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 215
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> Final integer | Y =  47
--> Product between X and Y =        10105
--> Cummulative sum of X*Y | summ =     30351674
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 332
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 567
--> Product between X and Y =       188244
--> Cummulative sum of X*Y | summ =     30539918
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 357
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 321
--> Product between X and Y =       114597
--> Cummulative sum of X*Y | summ =     30654515
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = w | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: w
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> Final integer | X =  62
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 985
--> Product between X and Y =        61070
--> Cummulative sum of X*Y | summ =     30715585
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 211
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 725
--> Product between X and Y =       152975
--> Cummulative sum of X*Y | summ =     30868560
--> Sequence is over, back to the start | state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 958
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 722
--> Product between X and Y =       691676
--> Cummulative sum of X*Y | summ =     31560236
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 157
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 358
--> Product between X and Y =        56206
--> Cummulative sum of X*Y | summ =     31616442
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 998
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 511
--> Product between X and Y =       509978
--> Cummulative sum of X*Y | summ =     32126420
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> Final integer | X =  97
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 681
--> Product between X and Y =        66057
--> Cummulative sum of X*Y | summ =     32192477
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 206
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 463
--> Product between X and Y =        95378
--> Cummulative sum of X*Y | summ =     32287855
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = s | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: s
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ^ | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ^
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 865
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 506
--> Product between X and Y =       437690
--> Cummulative sum of X*Y | summ =     32725545
--> Sequence is over, back to the start | state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 638
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 544
--> Product between X and Y =       347072
--> Cummulative sum of X*Y | summ =     33072617
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 501
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 647
--> Product between X and Y =       324147
--> Cummulative sum of X*Y | summ =     33396764
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> Final integer | X =  48
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 956
--> Product between X and Y =        45888
--> Cummulative sum of X*Y | summ =     33442652
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 501
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 473
--> Product between X and Y =       236973
--> Cummulative sum of X*Y | summ =     33679625
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 820
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 536
--> Product between X and Y =       439520
--> Cummulative sum of X*Y | summ =     34119145
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 772
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 914
--> Product between X and Y =       705608
--> Cummulative sum of X*Y | summ =     34824753
--> Sequence is over, back to the start | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> Final integer | X =  76
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 607
--> Product between X and Y =        46132
--> Cummulative sum of X*Y | summ =     34870885
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 705
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> Final integer | Y =  35
--> Product between X and Y =        24675
--> Cummulative sum of X*Y | summ =     34895560
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 733
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 730
--> Product between X and Y =       535090
--> Cummulative sum of X*Y | summ =     35430650
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 821
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 893
--> Product between X and Y =       733153
--> Cummulative sum of X*Y | summ =     36163803
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 947
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 531
--> Product between X and Y =       502857
--> Cummulative sum of X*Y | summ =     36666660
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 889
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 663
--> Product between X and Y =       589407
--> Cummulative sum of X*Y | summ =     37256067
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 493
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 430
--> Product between X and Y =       211990
--> Cummulative sum of X*Y | summ =     37468057
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = % | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 139
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 704
--> Product between X and Y =        97856
--> Cummulative sum of X*Y | summ =     37565913
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 923
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 691
--> Product between X and Y =       637793
--> Cummulative sum of X*Y | summ =     38203706
--> Sequence is over, back to the start | state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 583
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 859
--> Product between X and Y =       500797
--> Cummulative sum of X*Y | summ =     38704503
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = h | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> Final integer | X =  19
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 182
--> Product between X and Y =         3458
--> Cummulative sum of X*Y | summ =     38707961
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> Final integer | X =  77
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 374
--> Product between X and Y =        28798
--> Cummulative sum of X*Y | summ =     38736759
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 630
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 751
--> Product between X and Y =       473130
--> Cummulative sum of X*Y | summ =     39209889
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 740
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 291
--> Product between X and Y =       215340
--> Cummulative sum of X*Y | summ =     39425229
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 760
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 727
--> Product between X and Y =       552520
--> Cummulative sum of X*Y | summ =     39977749
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 996
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> Final integer | Y =  13
--> Product between X and Y =        12948
--> Cummulative sum of X*Y | summ =     39990697
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 865
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> Final integer | Y =  56
--> Product between X and Y =        48440
--> Cummulative sum of X*Y | summ =     40039137
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 995
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> Final integer | Y =  58
--> Product between X and Y =        57710
--> Cummulative sum of X*Y | summ =     40096847
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 323
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> Final integer | Y =  37
--> Product between X and Y =        11951
--> Cummulative sum of X*Y | summ =     40108798
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 348
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> Final integer | Y =  89
--> Product between X and Y =        30972
--> Cummulative sum of X*Y | summ =     40139770
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ) | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 502
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 269
--> Product between X and Y =       135038
--> Cummulative sum of X*Y | summ =     40274808
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 652
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 742
--> Product between X and Y =       483784
--> Cummulative sum of X*Y | summ =     40758592
--> Sequence is over, back to the start | state = 0

Character =   | io = -2
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> Final integer | X =  43
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 859
--> Product between X and Y =        36937
--> Cummulative sum of X*Y | summ =     40795529
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 162
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> Final integer | Y =  15
--> Product between X and Y =         2430
--> Cummulative sum of X*Y | summ =     40797959
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 322
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 158
--> Product between X and Y =        50876
--> Cummulative sum of X*Y | summ =     40848835
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 949
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 468
--> Product between X and Y =       444132
--> Cummulative sum of X*Y | summ =     41292967
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 890
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 635
--> Product between X and Y =       565150
--> Cummulative sum of X*Y | summ =     41858117
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = & | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: &
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 516
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 431
--> Product between X and Y =       222396
--> Cummulative sum of X*Y | summ =     42080513
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 516
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 755
--> Product between X and Y =       389580
--> Cummulative sum of X*Y | summ =     42470093
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 484
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 114
--> Product between X and Y =        55176
--> Cummulative sum of X*Y | summ =     42525269
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 623
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 440
--> Product between X and Y =       274120
--> Cummulative sum of X*Y | summ =     42799389
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 774
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 302
--> Product between X and Y =       233748
--> Cummulative sum of X*Y | summ =     43033137
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> Final integer | X =  91
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 958
--> Product between X and Y =        87178
--> Cummulative sum of X*Y | summ =     43120315
--> Sequence is over, back to the start | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 910
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 920
--> Product between X and Y =       837200
--> Cummulative sum of X*Y | summ =     43957515
--> Sequence is over, back to the start | state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 134
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 589
--> Product between X and Y =        78926
--> Cummulative sum of X*Y | summ =     44036441
--> Sequence is over, back to the start | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = * | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: *
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 204
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 437
--> Product between X and Y =        89148
--> Cummulative sum of X*Y | summ =     44125589
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 697
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 199
--> Product between X and Y =       138703
--> Cummulative sum of X*Y | summ =     44264292
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 928
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 999
--> Product between X and Y =       927072
--> Cummulative sum of X*Y | summ =     45191364
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 721
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 616
--> Product between X and Y =       444136
--> Cummulative sum of X*Y | summ =     45635500
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 166
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 276
--> Product between X and Y =        45816
--> Cummulative sum of X*Y | summ =     45681316
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 921
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 345
--> Product between X and Y =       317745
--> Cummulative sum of X*Y | summ =     45999061
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 858
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> Final integer | Y =  22
--> Product between X and Y =        18876
--> Cummulative sum of X*Y | summ =     46017937
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 812
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> Final integer | Y =  54
--> Product between X and Y =        43848
--> Cummulative sum of X*Y | summ =     46061785
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> Final integer | X =  11
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 654
--> Product between X and Y =         7194
--> Cummulative sum of X*Y | summ =     46068979
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 398
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 677
--> Product between X and Y =       269446
--> Cummulative sum of X*Y | summ =     46338425
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 649
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 529
--> Product between X and Y =       343321
--> Cummulative sum of X*Y | summ =     46681746
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> Final integer | X =  78
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 877
--> Product between X and Y =        68406
--> Cummulative sum of X*Y | summ =     46750152
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ' | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: '
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 826
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 788
--> Product between X and Y =       650888
--> Cummulative sum of X*Y | summ =     47401040
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 463
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 163
--> Product between X and Y =        75469
--> Cummulative sum of X*Y | summ =     47476509
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 342
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 950
--> Product between X and Y =       324900
--> Cummulative sum of X*Y | summ =     47801409
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 339
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 663
--> Product between X and Y =       224757
--> Cummulative sum of X*Y | summ =     48026166
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 568
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 433
--> Product between X and Y =       245944
--> Cummulative sum of X*Y | summ =     48272110
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 182
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 776
--> Product between X and Y =       141232
--> Cummulative sum of X*Y | summ =     48413342
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 705
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 962
--> Product between X and Y =       678210
--> Cummulative sum of X*Y | summ =     49091552
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 717
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 100
--> Product between X and Y =        71700
--> Cummulative sum of X*Y | summ =     49163252
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character =   | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied ::  
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = % | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: %
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 423
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 876
--> Product between X and Y =       370548
--> Cummulative sum of X*Y | summ =     49533800
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 630
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> Final integer | Y =  98
--> Product between X and Y =        61740
--> Cummulative sum of X*Y | summ =     49595540
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 356
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 570
--> Product between X and Y =       202920
--> Cummulative sum of X*Y | summ =     49798460
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 193
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 467
--> Product between X and Y =        90131
--> Cummulative sum of X*Y | summ =     49888591
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 171
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 718
--> Product between X and Y =       122778
--> Cummulative sum of X*Y | summ =     50011369
--> Sequence is over, back to the start | state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ) | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  20
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 284
--> Product between X and Y =         5680
--> Cummulative sum of X*Y | summ =     50017049
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 984
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 419
--> Product between X and Y =       412296
--> Cummulative sum of X*Y | summ =     50429345
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 503
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 701
--> Product between X and Y =       352603
--> Cummulative sum of X*Y | summ =     50781948
--> Sequence is over, back to the start | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = - | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: -
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 424
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 769
--> Product between X and Y =       326056
--> Cummulative sum of X*Y | summ =     51108004
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 707
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 101
--> Product between X and Y =        71407
--> Cummulative sum of X*Y | summ =     51179411
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 911
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 436
--> Product between X and Y =       397196
--> Cummulative sum of X*Y | summ =     51576607
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 194
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 212
--> Product between X and Y =        41128
--> Cummulative sum of X*Y | summ =     51617735
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 777
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 219
--> Product between X and Y =       170163
--> Cummulative sum of X*Y | summ =     51787898
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 948
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 616
--> Product between X and Y =       583968
--> Cummulative sum of X*Y | summ =     52371866
--> Sequence is over, back to the start | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ; | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ;
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 728
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 277
--> Product between X and Y =       201656
--> Cummulative sum of X*Y | summ =     52573522
--> Sequence is over, back to the start | state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 587
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 483
--> Product between X and Y =       283521
--> Cummulative sum of X*Y | summ =     52857043
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 399
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 787
--> Product between X and Y =       314013
--> Cummulative sum of X*Y | summ =     53171056
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = + | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: +
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 226
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 744
--> Product between X and Y =       168144
--> Cummulative sum of X*Y | summ =     53339200
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 384
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 508
--> Product between X and Y =       195072
--> Cummulative sum of X*Y | summ =     53534272
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> Final integer | X =  71
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 783
--> Product between X and Y =        55593
--> Cummulative sum of X*Y | summ =     53589865
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 358
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 304
--> Product between X and Y =       108832
--> Cummulative sum of X*Y | summ =     53698697
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = # | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: #
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 914
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 176
--> Product between X and Y =       160864
--> Cummulative sum of X*Y | summ =     53859561
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 326
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 407
--> Product between X and Y =       132682
--> Cummulative sum of X*Y | summ =     53992243
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 506
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 431
--> Product between X and Y =       218086
--> Cummulative sum of X*Y | summ =     54210329
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 906
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 775
--> Product between X and Y =       702150
--> Cummulative sum of X*Y | summ =     54912479
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 969
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 415
--> Product between X and Y =       402135
--> Cummulative sum of X*Y | summ =     55314614
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 710
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 613
--> Product between X and Y =       435230
--> Cummulative sum of X*Y | summ =     55749844
--> Sequence is over, back to the start | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 312
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 425
--> Product between X and Y =       132600
--> Cummulative sum of X*Y | summ =     55882444
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 766
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 549
--> Product between X and Y =       420534
--> Cummulative sum of X*Y | summ =     56302978
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 782
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 679
--> Product between X and Y =       530978
--> Cummulative sum of X*Y | summ =     56833956
--> Sequence is over, back to the start | state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = + | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: +
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 876
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 214
--> Product between X and Y =       187464
--> Cummulative sum of X*Y | summ =     57021420
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 120
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 331
--> Product between X and Y =        39720
--> Cummulative sum of X*Y | summ =     57061140
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 276
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 127
--> Product between X and Y =        35052
--> Cummulative sum of X*Y | summ =     57096192
--> Sequence is over, back to the start | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> Final integer | X =  36
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 647
--> Product between X and Y =        23292
--> Cummulative sum of X*Y | summ =     57119484
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 166
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 678
--> Product between X and Y =       112548
--> Cummulative sum of X*Y | summ =     57232032
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 577
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 776
--> Product between X and Y =       447752
--> Cummulative sum of X*Y | summ =     57679784
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 540
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 542
--> Product between X and Y =       292680
--> Cummulative sum of X*Y | summ =     57972464
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> Final integer | X =  21
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 652
--> Product between X and Y =        13692
--> Cummulative sum of X*Y | summ =     57986156
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 696
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 919
--> Product between X and Y =       639624
--> Cummulative sum of X*Y | summ =     58625780
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 957
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 516
--> Product between X and Y =       493812
--> Cummulative sum of X*Y | summ =     59119592
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 949
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 720
--> Product between X and Y =       683280
--> Cummulative sum of X*Y | summ =     59802872
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 302
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> Final integer | Y =  42
--> Product between X and Y =        12684
--> Cummulative sum of X*Y | summ =     59815556
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = > | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: >
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 730
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 949
--> Product between X and Y =       692770
--> Cummulative sum of X*Y | summ =     60508326
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 664
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 358
--> Product between X and Y =       237712
--> Cummulative sum of X*Y | summ =     60746038
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 739
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 738
--> Product between X and Y =       545382
--> Cummulative sum of X*Y | summ =     61291420
--> Sequence is over, back to the start | state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 377
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 419
--> Product between X and Y =       157963
--> Cummulative sum of X*Y | summ =     61449383
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ] | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ]
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 596
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> Final integer | Y =  35
--> Product between X and Y =        20860
--> Cummulative sum of X*Y | summ =     61470243
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 427
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 664
--> Product between X and Y =       283528
--> Cummulative sum of X*Y | summ =     61753771
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 197
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 195
--> Product between X and Y =        38415
--> Cummulative sum of X*Y | summ =     61792186
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 737
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 893
--> Product between X and Y =       658141
--> Cummulative sum of X*Y | summ =     62450327
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 709
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 889
--> Product between X and Y =       630301
--> Cummulative sum of X*Y | summ =     63080628
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 129
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 840
--> Product between X and Y =       108360
--> Cummulative sum of X*Y | summ =     63188988
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 920
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 817
--> Product between X and Y =       751640
--> Cummulative sum of X*Y | summ =     63940628
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 269
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 369
--> Product between X and Y =        99261
--> Cummulative sum of X*Y | summ =     64039889
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 828
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 795
--> Product between X and Y =       658260
--> Cummulative sum of X*Y | summ =     64698149
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 682
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 546
--> Product between X and Y =       372372
--> Cummulative sum of X*Y | summ =     65070521
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 243
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 207
--> Product between X and Y =        50301
--> Cummulative sum of X*Y | summ =     65120822
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 503
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 124
--> Product between X and Y =        62372
--> Cummulative sum of X*Y | summ =     65183194
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 750
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 321
--> Product between X and Y =       240750
--> Cummulative sum of X*Y | summ =     65423944
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 970
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 615
--> Product between X and Y =       596550
--> Cummulative sum of X*Y | summ =     66020494
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 876
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 1
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> Final integer | Y =   7
--> Product between X and Y =         6132
--> Cummulative sum of X*Y | summ =     66026626
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = w | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 312
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> Final integer | Y =  66
--> Product between X and Y =        20592
--> Cummulative sum of X*Y | summ =     66047218
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ? | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 453
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 529
--> Product between X and Y =       239637
--> Cummulative sum of X*Y | summ =     66286855
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 644
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 160
--> Product between X and Y =       103040
--> Cummulative sum of X*Y | summ =     66389895
--> Sequence is over, back to the start | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 227
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 457
--> Product between X and Y =       103739
--> Cummulative sum of X*Y | summ =     66493634
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 925
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 534
--> Product between X and Y =       493950
--> Cummulative sum of X*Y | summ =     66987584
--> Sequence is over, back to the start | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 739
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 218
--> Product between X and Y =       161102
--> Cummulative sum of X*Y | summ =     67148686
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 332
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 459
--> Product between X and Y =       152388
--> Cummulative sum of X*Y | summ =     67301074
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = b | io =  0
--> state = 1
--> instruct_state = 0

Character = i | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = p | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io = -2
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = s | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: s
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 173
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 615
--> Product between X and Y =       106395
--> Cummulative sum of X*Y | summ =     67407469
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 942
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 267
--> Product between X and Y =       251514
--> Cummulative sum of X*Y | summ =     67658983
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = [ | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: [
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 428
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 140
--> Product between X and Y =        59920
--> Cummulative sum of X*Y | summ =     67718903
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 601
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 739
--> Product between X and Y =       444139
--> Cummulative sum of X*Y | summ =     68163042
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 185
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 413
--> Product between X and Y =        76405
--> Cummulative sum of X*Y | summ =     68239447
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 981
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 447
--> Product between X and Y =       438507
--> Cummulative sum of X*Y | summ =     68677954
--> Sequence is over, back to the start | state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> Final integer | X =  31
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 754
--> Product between X and Y =        23374
--> Cummulative sum of X*Y | summ =     68701328
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 851
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 878
--> Product between X and Y =       747178
--> Cummulative sum of X*Y | summ =     69448506
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 470
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 861
--> Product between X and Y =       404670
--> Cummulative sum of X*Y | summ =     69853176
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 861
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 914
--> Product between X and Y =       786954
--> Cummulative sum of X*Y | summ =     70640130
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 404
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> Final integer | Y =  36
--> Product between X and Y =        14544
--> Cummulative sum of X*Y | summ =     70654674
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 192
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> Final integer | Y =  10
--> Product between X and Y =         1920
--> Cummulative sum of X*Y | summ =     70656594
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 439
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 983
--> Product between X and Y =       431537
--> Cummulative sum of X*Y | summ =     71088131
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 264
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 570
--> Product between X and Y =       150480
--> Cummulative sum of X*Y | summ =     71238611
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = > | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: >
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 740
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 187
--> Product between X and Y =       138380
--> Cummulative sum of X*Y | summ =     71376991
--> Sequence is over, back to the start | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 515
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 176
--> Product between X and Y =        90640
--> Cummulative sum of X*Y | summ =     71467631
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 861
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> Final integer | Y =  78
--> Product between X and Y =        67158
--> Cummulative sum of X*Y | summ =     71534789
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 425
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 831
--> Product between X and Y =       353175
--> Cummulative sum of X*Y | summ =     71887964
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 867
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 197
--> Product between X and Y =       170799
--> Cummulative sum of X*Y | summ =     72058763
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 203
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 803
--> Product between X and Y =       163009
--> Cummulative sum of X*Y | summ =     72221772
--> Sequence is over, back to the start | state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 641
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 477
--> Product between X and Y =       305757
--> Cummulative sum of X*Y | summ =     72527529
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = @ | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: @
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 398
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 141
--> Product between X and Y =        56118
--> Cummulative sum of X*Y | summ =     72583647
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> Final integer | X =  17
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 892
--> Product between X and Y =        15164
--> Cummulative sum of X*Y | summ =     72598811
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = * | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: *
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 581
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 913
--> Product between X and Y =       530453
--> Cummulative sum of X*Y | summ =     73129264
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 485
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 202
--> Product between X and Y =        97970
--> Cummulative sum of X*Y | summ =     73227234
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 637
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 719
--> Product between X and Y =       458003
--> Cummulative sum of X*Y | summ =     73685237
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 152
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 221
--> Product between X and Y =        33592
--> Cummulative sum of X*Y | summ =     73718829
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 336
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 492
--> Product between X and Y =       165312
--> Cummulative sum of X*Y | summ =     73884141
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ' | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> Final integer | X =  76
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 674
--> Product between X and Y =        51224
--> Cummulative sum of X*Y | summ =     73935365
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 172
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 533
--> Product between X and Y =        91676
--> Cummulative sum of X*Y | summ =     74027041
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 166
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 405
--> Product between X and Y =        67230
--> Cummulative sum of X*Y | summ =     74094271
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = @ | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: @
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 168
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 469
--> Product between X and Y =        78792
--> Cummulative sum of X*Y | summ =     74173063
--> Sequence is over, back to the start | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 319
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 476
--> Product between X and Y =       151844
--> Cummulative sum of X*Y | summ =     74324907
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 953
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> Final integer | Y =  57
--> Product between X and Y =        54321
--> Cummulative sum of X*Y | summ =     74379228
--> Sequence is over, back to the start | state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 534
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 477
--> Product between X and Y =       254718
--> Cummulative sum of X*Y | summ =     74633946
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ' | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: '
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 534
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 163
--> Product between X and Y =        87042
--> Cummulative sum of X*Y | summ =     74720988
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ; | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 819
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 924
--> Product between X and Y =       756756
--> Cummulative sum of X*Y | summ =     75477744
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 914
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 787
--> Product between X and Y =       719318
--> Cummulative sum of X*Y | summ =     76197062
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 743
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 314
--> Product between X and Y =       233302
--> Cummulative sum of X*Y | summ =     76430364
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 127
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 154
--> Product between X and Y =        19558
--> Cummulative sum of X*Y | summ =     76449922
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 402
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 199
--> Product between X and Y =        79998
--> Cummulative sum of X*Y | summ =     76529920
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 747
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 407
--> Product between X and Y =       304029
--> Cummulative sum of X*Y | summ =     76833949
--> Sequence is over, back to the start | state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 315
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> Final integer | Y =  12
--> Product between X and Y =         3780
--> Cummulative sum of X*Y | summ =     76837729
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 244
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 473
--> Product between X and Y =       115412
--> Cummulative sum of X*Y | summ =     76953141
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 503
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> Final integer | Y =  91
--> Product between X and Y =        45773
--> Cummulative sum of X*Y | summ =     76998914
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 718
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 938
--> Product between X and Y =       673484
--> Cummulative sum of X*Y | summ =     77672398
--> Sequence is over, back to the start | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 695
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 933
--> Product between X and Y =       648435
--> Cummulative sum of X*Y | summ =     78320833
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 643
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 847
--> Product between X and Y =       544621
--> Cummulative sum of X*Y | summ =     78865454
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 128
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 209
--> Product between X and Y =        26752
--> Cummulative sum of X*Y | summ =     78892206
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 145
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 427
--> Product between X and Y =        61915
--> Cummulative sum of X*Y | summ =     78954121
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 838
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 702
--> Product between X and Y =       588276
--> Cummulative sum of X*Y | summ =     79542397
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 750
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 117
--> Product between X and Y =        87750
--> Cummulative sum of X*Y | summ =     79630147
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 105
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 945
--> Product between X and Y =        99225
--> Cummulative sum of X*Y | summ =     79729372
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 445
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 716
--> Product between X and Y =       318620
--> Cummulative sum of X*Y | summ =     80047992
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 848
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 545
--> Product between X and Y =       462160
--> Cummulative sum of X*Y | summ =     80510152
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  2
--> Final integer | X =  92
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 844
--> Product between X and Y =        77648
--> Cummulative sum of X*Y | summ =     80587800
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 678
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 890
--> Product between X and Y =       603420
--> Cummulative sum of X*Y | summ =     81191220
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 784
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 836
--> Product between X and Y =       655424
--> Cummulative sum of X*Y | summ =     81846644
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 184
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 623
--> Product between X and Y =       114632
--> Cummulative sum of X*Y | summ =     81961276
--> Sequence is over, back to the start | state = 0

Character =   | io = -2
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 590
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 239
--> Product between X and Y =       141010
--> Cummulative sum of X*Y | summ =     82102286
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> Final integer | X =  67
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 657
--> Product between X and Y =        44019
--> Cummulative sum of X*Y | summ =     82146305
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 556
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 689
--> Product between X and Y =       383084
--> Cummulative sum of X*Y | summ =     82529389
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 570
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 791
--> Product between X and Y =       450870
--> Cummulative sum of X*Y | summ =     82980259
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = # | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: #
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 353
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 577
--> Product between X and Y =       203681
--> Cummulative sum of X*Y | summ =     83183940
--> Sequence is over, back to the start | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 147
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 848
--> Product between X and Y =       124656
--> Cummulative sum of X*Y | summ =     83308596
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 974
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  0
--> Final integer | Y =  10
--> Product between X and Y =         9740
--> Cummulative sum of X*Y | summ =     83318336
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 500
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 481
--> Product between X and Y =       240500
--> Cummulative sum of X*Y | summ =     83558836
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 145
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 394
--> Product between X and Y =        57130
--> Cummulative sum of X*Y | summ =     83615966
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> Final integer | X =  97
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 499
--> Product between X and Y =        48403
--> Cummulative sum of X*Y | summ =     83664369
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 784
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 687
--> Product between X and Y =       538608
--> Cummulative sum of X*Y | summ =     84202977
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 290
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 184
--> Product between X and Y =        53360
--> Cummulative sum of X*Y | summ =     84256337
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 553
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 555
--> Product between X and Y =       306915
--> Cummulative sum of X*Y | summ =     84563252
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 317
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 461
--> Product between X and Y =       146137
--> Cummulative sum of X*Y | summ =     84709389
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 789
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 586
--> Product between X and Y =       462354
--> Cummulative sum of X*Y | summ =     85171743
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 810
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 145
--> Product between X and Y =       117450
--> Cummulative sum of X*Y | summ =     85289193
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 468
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 772
--> Product between X and Y =       361296
--> Cummulative sum of X*Y | summ =     85650489
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 663
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 347
--> Product between X and Y =       230061
--> Cummulative sum of X*Y | summ =     85880550
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 704
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 336
--> Product between X and Y =       236544
--> Cummulative sum of X*Y | summ =     86117094
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 170
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 815
--> Product between X and Y =       138550
--> Cummulative sum of X*Y | summ =     86255644
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 944
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 939
--> Product between X and Y =       886416
--> Cummulative sum of X*Y | summ =     87142060
--> Sequence is over, back to the start | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 280
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 533
--> Product between X and Y =       149240
--> Cummulative sum of X*Y | summ =     87291300
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = @ | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 738
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> Final integer | Y =  82
--> Product between X and Y =        60516
--> Cummulative sum of X*Y | summ =     87351816
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = * | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 488
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 256
--> Product between X and Y =       124928
--> Cummulative sum of X*Y | summ =     87476744
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 584
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 361
--> Product between X and Y =       210824
--> Cummulative sum of X*Y | summ =     87687568
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 896
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 700
--> Product between X and Y =       627200
--> Cummulative sum of X*Y | summ =     88314768
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 794
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 457
--> Product between X and Y =       362858
--> Cummulative sum of X*Y | summ =     88677626
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 575
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 697
--> Product between X and Y =       400775
--> Cummulative sum of X*Y | summ =     89078401
--> Sequence is over, back to the start | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 124
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 326
--> Product between X and Y =        40424
--> Cummulative sum of X*Y | summ =     89118825
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 524
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 584
--> Product between X and Y =       306016
--> Cummulative sum of X*Y | summ =     89424841
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 245
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 768
--> Product between X and Y =       188160
--> Cummulative sum of X*Y | summ =     89613001
--> Sequence is over, back to the start | state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 704
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 867
--> Product between X and Y =       610368
--> Cummulative sum of X*Y | summ =     90223369
--> Sequence is over, back to the start | state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> Final integer | X =  90
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 724
--> Product between X and Y =        65160
--> Cummulative sum of X*Y | summ =     90288529
--> Sequence is over, back to the start | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 434
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 982
--> Product between X and Y =       426188
--> Cummulative sum of X*Y | summ =     90714717
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 947
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 645
--> Product between X and Y =       610815
--> Cummulative sum of X*Y | summ =     91325532
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 637
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 644
--> Product between X and Y =       410228
--> Cummulative sum of X*Y | summ =     91735760
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = h | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: h
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 968
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 268
--> Product between X and Y =       259424
--> Cummulative sum of X*Y | summ =     91995184
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ! | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: !
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 512
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 161
--> Product between X and Y =        82432
--> Cummulative sum of X*Y | summ =     92077616
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = - | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence broken | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 627
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 181
--> Product between X and Y =       113487
--> Cummulative sum of X*Y | summ =     92191103
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 914
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 709
--> Product between X and Y =       648026
--> Cummulative sum of X*Y | summ =     92839129
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 372
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 426
--> Product between X and Y =       158472
--> Cummulative sum of X*Y | summ =     92997601
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ] | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ]
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 439
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 918
--> Product between X and Y =       403002
--> Cummulative sum of X*Y | summ =     93400603
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 1
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> Final integer | X =   8
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 169
--> Product between X and Y =         1352
--> Cummulative sum of X*Y | summ =     93401955
--> Sequence is over, back to the start | state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 417
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 187
--> Product between X and Y =        77979
--> Cummulative sum of X*Y | summ =     93479934
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 715
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 150
--> Product between X and Y =       107250
--> Cummulative sum of X*Y | summ =     93587184
--> Sequence is over, back to the start | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 208
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 512
--> Product between X and Y =       106496
--> Cummulative sum of X*Y | summ =     93693680
--> Sequence is over, back to the start | state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 998
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 345
--> Product between X and Y =       344310
--> Cummulative sum of X*Y | summ =     94037990
--> Sequence is over, back to the start | state = 0

Character =   | io = -2
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 762
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 958
--> Product between X and Y =       729996
--> Cummulative sum of X*Y | summ =     94767986
--> Sequence is over, back to the start | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 962
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 739
--> Product between X and Y =       710918
--> Cummulative sum of X*Y | summ =     95478904
--> Sequence is over, back to the start | state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 808
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 716
--> Product between X and Y =       578528
--> Cummulative sum of X*Y | summ =     96057432
--> Sequence is over, back to the start | state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 937
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 746
--> Product between X and Y =       699002
--> Cummulative sum of X*Y | summ =     96756434
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 191
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 854
--> Product between X and Y =       163114
--> Cummulative sum of X*Y | summ =     96919548
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = > | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: >
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A different character | Sequence broken | state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 453
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 745
--> Product between X and Y =       337485
--> Cummulative sum of X*Y | summ =     97257033
--> Sequence is over, back to the start | state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 857
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 414
--> Product between X and Y =       354798
--> Cummulative sum of X*Y | summ =     97611831
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 724
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 307
--> Product between X and Y =       222268
--> Cummulative sum of X*Y | summ =     97834099
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 514
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 942
--> Product between X and Y =       484188
--> Cummulative sum of X*Y | summ =     98318287
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 9 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 499
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 812
--> Product between X and Y =       405188
--> Cummulative sum of X*Y | summ =     98723475
--> Sequence is over, back to the start | state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 870
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> Final integer | Y =  75
--> Product between X and Y =        65250
--> Cummulative sum of X*Y | summ =     98788725
--> Sequence is over, back to the start | state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 715
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 952
--> Product between X and Y =       680680
--> Cummulative sum of X*Y | summ =     99469405
--> Sequence is over, back to the start | state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 679
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 508
--> Product between X and Y =       344932
--> Cummulative sum of X*Y | summ =     99814337
--> Sequence is over, back to the start | state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 976
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 825
--> Product between X and Y =       805200
--> Cummulative sum of X*Y | summ =    100619537
--> Sequence is over, back to the start | state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 8 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 1

Character = ' | io =  0
--> state = 1
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 1

Character = t | io =  0
--> state = 1
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 1

Character = ( | io =  0
--> state = 1
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = [ | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = f | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = s | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = c | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = % | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = : | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = a | io =  0
--> state = 1
--> instruct_state = 0

Character = t | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 113
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 797
--> Product between X and Y =        90061
--> Cummulative sum of X*Y | summ =    100709598
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 819
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 538
--> Product between X and Y =       440622
--> Cummulative sum of X*Y | summ =    101150220
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = ? | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = > | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ^ | io =  0
--> state = 1
--> instruct_state = 0

Character = # | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = n | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ! | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = ; | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = y | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = @ | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = + | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = o | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = / | io =  0
--> state = 1
--> instruct_state = 0

Character = $ | io =  0
--> state = 1
--> instruct_state = 0

Character = ' | io =  0
--> state = 1
--> instruct_state = 0

Character = ~ | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = { | io =  0
--> state = 1
--> instruct_state = 0

Character = ] | io =  0
--> state = 1
--> instruct_state = 0

Character = } | io =  0
--> state = 1
--> instruct_state = 0

Character = d | io =  0
--> state = 1
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 1
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 1
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 1

Character = ) | io =  0
--> state = 1
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 226
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 790
--> Product between X and Y =       178540
--> Cummulative sum of X*Y | summ =    101328760
--> Sequence is over, back to the start | state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 901
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 307
--> Product between X and Y =       276607
--> Cummulative sum of X*Y | summ =    101605367
--> Sequence is over, back to the start | state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  9
--> Final integer | X =  19
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 239
--> Product between X and Y =         4541
--> Cummulative sum of X*Y | summ =    101609908
--> Sequence is over, back to the start | state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 964
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 735
--> Product between X and Y =       708540
--> Cummulative sum of X*Y | summ =    102318448
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 484
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 646
--> Product between X and Y =       312664
--> Cummulative sum of X*Y | summ =    102631112
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = ^ | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  7
--> Final integer | X = 297
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 515
--> Product between X and Y =       152955
--> Cummulative sum of X*Y | summ =    102784067
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 491
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 320
--> Product between X and Y =       157120
--> Cummulative sum of X*Y | summ =    102941187
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 675
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  9
--> Final integer | Y = 449
--> Product between X and Y =       303075
--> Cummulative sum of X*Y | summ =    103244262
--> Sequence is over, back to the start | state = 0

Character = $ | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ! | io =  0
--> state = 0
--> instruct_state = 0

Character = } | io =  0
--> state = 0
--> instruct_state = 0

Character = @ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry = -1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 2
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> Final integer | X =  21
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  6
--> Final integer | Y =  16
--> Product between X and Y =          336
--> Cummulative sum of X*Y | summ =    103244598
--> Sequence is over, back to the start | state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = / | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  6
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 263
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 684
--> Product between X and Y =       179892
--> Cummulative sum of X*Y | summ =    103424490
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 751
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  3
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 630
--> Product between X and Y =       473130
--> Cummulative sum of X*Y | summ =    103897620
--> Sequence is over, back to the start | state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | X = 445
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 676
--> Product between X and Y =       300820
--> Cummulative sum of X*Y | summ =    104198440
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 840
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry = -1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 2
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> Final integer | Y =  40
--> Product between X and Y =        33600
--> Cummulative sum of X*Y | summ =    104232040
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 298
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 977
--> Product between X and Y =       291146
--> Cummulative sum of X*Y | summ =    104523186
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = & | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 404
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  4
--> Final integer | Y = 614
--> Product between X and Y =       248056
--> Cummulative sum of X*Y | summ =    104771242
--> Sequence is over, back to the start | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  1
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  2
--> Final integer | X = 182
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  7
--> Final integer | Y = 657
--> Product between X and Y =       119574
--> Cummulative sum of X*Y | summ =    104890816
--> Sequence is over, back to the start | state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 450
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  2
--> Final integer | Y = 272
--> Product between X and Y =       122400
--> Cummulative sum of X*Y | summ =    105013216
--> Sequence is over, back to the start | state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  8
--> Final integer | X = 228
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 343
--> Product between X and Y =        78204
--> Cummulative sum of X*Y | summ =    105091420
--> Sequence is over, back to the start | state = 0

Character = : | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = [ | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = a | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  0
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  1
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  9
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  0
--> Final integer | X = 970
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | Y = 721
--> Product between X and Y =       699370
--> Cummulative sum of X*Y | summ =    105790790
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = # | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 2

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 8 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  8
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  8
--> (*) Index = 2 | Entry =  7
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 879
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  8
--> Final integer | Y = 558
--> Product between X and Y =       490482
--> Cummulative sum of X*Y | summ =    106281272
--> Sequence is over, back to the start | state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = % | io =  0
--> state = 0
--> instruct_state = 0

Character = + | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = - | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ] | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  3
--> Final integer | X = 723
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  0
--> Final integer | Y = 300
--> Product between X and Y =       216900
--> Cummulative sum of X*Y | summ =    106498172
--> Sequence is over, back to the start | state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character =   | io =  0
--> state = 0
--> instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = y | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 8 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 8
--> (*) Read status =  0 | Integer read = 8
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  8
--> Advance to store next digit :: 3

Character = 4 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  4
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  8
--> (*) Index = 3 | Entry =  4
--> Final integer | X = 384
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  6
--> Final integer | Y = 706
--> Product between X and Y =       271104
--> Cummulative sum of X*Y | summ =    106769276
--> Sequence is over, back to the start | state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = ( | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: do( | Path to do instruct | Even states from now on | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 4
--> Sequence complete | do() | Enabling MUL FSM = 1 | Resetting instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  9
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 799
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 503
--> Product between X and Y =       401897
--> Cummulative sum of X*Y | summ =    107171173
--> Sequence is over, back to the start | state = 0

Character = ~ | io =  0
--> state = 0
--> instruct_state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = 2 | io =  0
--> state = 0
--> instruct_state = 0

Character = 7 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 6 | io =  0
--> state = 0
--> instruct_state = 0

Character = 0 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = > | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 6 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  6
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 2

Character = 0 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 0
--> (*) Read status =  0 | Integer read = 0
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  0
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  2
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  6
--> Final integer | X = 216
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  4
--> (*) Index = 2 | Entry =  0
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 403
--> Product between X and Y =        87048
--> Cummulative sum of X*Y | summ =    107258221
--> Sequence is over, back to the start | state = 0

Character = s | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = l | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = c | io =  0
--> state = 0
--> instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = < | io =  0
--> state = 0
--> instruct_state = 0

Character = { | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 7 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 7
--> (*) Read status =  0 | Integer read = 7
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  7
--> Advance to store next digit :: 2

Character = 2 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 2
--> (*) Read status =  0 | Integer read = 2
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  2
--> Advance to store next digit :: 3

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 2

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 3

Character = 3 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  3
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  7
--> (*) Index = 2 | Entry =  2
--> (*) Index = 3 | Entry =  1
--> Final integer | X = 721
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  5
--> (*) Index = 2 | Entry =  5
--> (*) Index = 3 | Entry =  3
--> Final integer | Y = 553
--> Product between X and Y =       398713
--> Cummulative sum of X*Y | summ =    107656934
--> Sequence is over, back to the start | state = 0

Character = f | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = ( | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence broken | state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ? | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = n | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0
--> Gets into MUL FSM CASE(1) but nothing happens yet

Character = u | io =  0
--> state = 1
--> instruct_state = 0
--> Sequence is now :: mu | state = 2

Character = l | io =  0
--> state = 2
--> instruct_state = 0
--> Sequence is now :: mul | state = 3

Character = ( | io =  0
--> state = 3
--> instruct_state = 0
--> Sequence is now :: mul( | state = 4
--> Puting X_wip integer at the start :: 1
--> Initial state of X_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 3 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 3
--> (*) Read status =  0 | Integer read = 3
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  3
--> Advance to store next digit :: 2

Character = 1 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 1
--> (*) Read status =  0 | Integer read = 1
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  1
--> Advance to store next digit :: 3

Character = 9 | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 9
--> (*) Read status =  0 | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the parenthesis :: So it is X
--> Store digit:  9
--> Advance to store next digit :: 4

Character = , | io =  0
--> state = 4
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: ,
--> (*) Read status = ** | Integer read = 9
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> It is a comma character. mul(X, | X has finished
--> Sequence is now :: mul( | state = 5
--> Puting Y_wip integer at the start :: 1
--> Initial state of Y_wip:
--> (*) Index = 1 | Entry = -1
--> (*) Index = 2 | Entry = -1
--> (*) Index = 3 | Entry = -1

Character = 6 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 6
--> (*) Read status =  0 | Integer read = 6
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  6
--> Advance to store next digit :: 2

Character = 4 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 4
--> (*) Read status =  0 | Integer read = 4
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  4
--> Advance to store next digit :: 3

Character = 5 | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: 5
--> (*) Read status =  0 | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 1
--> It IS an integer, and after the comma :: So it is Y
--> Store digit:  5
--> Advance to store next digit :: 4

Character = ) | io =  0
--> state = 5
--> instruct_state = 0
--> is_it_int subroutine has been called | Arguments:
--> (*) File character being studied :: )
--> (*) Read status = ** | Integer read = 5
--> (*) Conclusion, is it an integer? (0: No, 1: Yes) :: 0
--> It is NOT an integer. So what is it?
--> A closing parenthesis. mul(X,Y) is formed. Analyzing integers
--> Final state of X_wip:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Length of actual X integer (number of elements of X_wip that are not -1) = 3
--> Result | X_clean elements:
--> (*) Index = 1 | Entry =  3
--> (*) Index = 2 | Entry =  1
--> (*) Index = 3 | Entry =  9
--> Final integer | X = 319
--> Final state of Y_wip:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Length of actual Y integer (number of elements of Y_wip that are not -1) = 3
--> Result | Y_clean elements:
--> (*) Index = 1 | Entry =  6
--> (*) Index = 2 | Entry =  4
--> (*) Index = 3 | Entry =  5
--> Final integer | Y = 645
--> Product between X and Y =       205755
--> Cummulative sum of X*Y | summ =    107862689
--> Sequence is over, back to the start | state = 0

Character = d | io =  0
--> state = 0
--> instruct_state = 1
--> Gets into INSTRUCT FSM CASE(1) but nothing happens yet

Character = o | io =  0
--> state = 0
--> instruct_state = 1
--> Sequence is now :: do | instruct_state = 2

Character = n | io =  0
--> state = 0
--> instruct_state = 2
--> Sequence is now :: don | Path to dont instruct | Odd states from now on | instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 3
--> Sequence is now :: don' | instruct_state = 0

Character = t | io =  0
--> state = 0
--> instruct_state = 5
--> Sequence is now :: don't | instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 7
--> Sequence is now :: don't( | instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 9
--> Sequence complete | don't() | Disabling MUL FSM = 0 | Resetting instruct_state = 0

Character = * | io =  0
--> state = 0
--> instruct_state = 0

Character = ' | io =  0
--> state = 0
--> instruct_state = 0

Character = ; | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = r | io =  0
--> state = 0
--> instruct_state = 0

Character = e | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = h | io =  0
--> state = 0
--> instruct_state = 0

Character = o | io =  0
--> state = 0
--> instruct_state = 0

Character = w | io =  0
--> state = 0
--> instruct_state = 0

Character = ( | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 5 | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = , | io =  0
--> state = 0
--> instruct_state = 0

Character = 1 | io =  0
--> state = 0
--> instruct_state = 0

Character = 4 | io =  0
--> state = 0
--> instruct_state = 0

Character = 3 | io =  0
--> state = 0
--> instruct_state = 0

Character = ) | io =  0
--> state = 0
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = < | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = * | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 5 | io =  0
--> state = 1
--> instruct_state = 0

Character = 6 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 9 | io =  0
--> state = 1
--> instruct_state = 0

Character = 2 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = 0 | io =  0
--> state = 1
--> instruct_state = 0

Character = 7 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = m | io =  0
--> state = 1
--> instruct_state = 0

Character = u | io =  0
--> state = 1
--> instruct_state = 0

Character = l | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = 1 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = , | io =  0
--> state = 1
--> instruct_state = 0

Character = 8 | io =  0
--> state = 1
--> instruct_state = 0

Character = 3 | io =  0
--> state = 1
--> instruct_state = 0

Character = 4 | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character = & | io =  0
--> state = 1
--> instruct_state = 0

Character = - | io =  0
--> state = 1
--> instruct_state = 0

Character = w | io =  0
--> state = 1
--> instruct_state = 0

Character = h | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = r | io =  0
--> state = 1
--> instruct_state = 0

Character = e | io =  0
--> state = 1
--> instruct_state = 0

Character = ( | io =  0
--> state = 1
--> instruct_state = 0

Character = ) | io =  0
--> state = 1
--> instruct_state = 0

Character =   | io = -2
--> state = 1
--> instruct_state = 0

Character =   | io = -1
--> state = 1
--> instruct_state = 0

Sum of products =    107862689
